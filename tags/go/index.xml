<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Go on </title>
    <link>https://trieutrng.github.io/tags/go/</link>
    <description>Recent content in Go on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>trieutrng@gmail.com (Trieu Truong)</managingEditor>
    <webMaster>trieutrng@gmail.com (Trieu Truong)</webMaster>
    <lastBuildDate>Thu, 06 Nov 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://trieutrng.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A little about TLS</title>
      <link>https://trieutrng.github.io/notes/2025/11/06/a-little-about-tls/</link>
      <pubDate>Thu, 06 Nov 2025 00:00:00 +0000</pubDate><author>trieutrng@gmail.com (Trieu Truong)</author>
      <guid>https://trieutrng.github.io/notes/2025/11/06/a-little-about-tls/</guid>
      <description>&lt;p&gt;TLS (Transport Layer Security) is the additional layer laid immediately above the socket and below the application layer in TCP/UDP protocol. It&amp;rsquo;s laid there to encrypt and decrypt messages passed through to make sure no one in the mdidle could see the actual message.&lt;/p&gt;&#xA;&lt;p&gt;We know that if server and client want to hide and read the messages, they should have the same key to encrypt and decrypt (symmetric encryption). But how both ends can securely share the key through insecure network? Let&amp;rsquo;s look at certain steps both ends should go through to make it happended.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>TLS (Transport Layer Security) is the additional layer laid immediately above the socket and below the application layer in TCP/UDP protocol. It&rsquo;s laid there to encrypt and decrypt messages passed through to make sure no one in the mdidle could see the actual message.</p>
<p>We know that if server and client want to hide and read the messages, they should have the same key to encrypt and decrypt (symmetric encryption). But how both ends can securely share the key through insecure network? Let&rsquo;s look at certain steps both ends should go through to make it happended.</p>
<h1 id="the-actual-tls-flow">The actual TLS flow</h1>
<p>Overrall, the TLS protocol help both client and server to securly shared a set of secret to encryp/decrypt the communication. It uses a set of cryptograhpy algorithms over the network in certains of steps to share essential information in order to have the keys set generated securely at both ends.</p>
<p><img src="tls_handshake.png" alt="TLS Handshake"></p>
<p>Generally, the client and server wouldn&rsquo;t share the shared session key through the network, it is calculated by using key exchange algorithms (ECDH, .etc) on key pairs generated by client and server to generate base secret and then using key derivation algorithms (HKDF, .etc) to derive more keys. The decision behind generating many keys is for preventing keys leak.</p>
<p>To prove that the server who client is talking to is authenticated, the certificate is provided by the server. This certificate is signed by an trusted authority.</p>
<p>One interesting point is the calculated keys are also based on the hash which is generated by hashing all the decrypted messages so far.</p>
<p>The application keys are calculated the same way with handshake keys. These keys are used for encrypt and decrypt message onward.</p>
<h1 id="more-on-this">More on this</h1>
<p>If the message to return to client is large, it will be splited into chunks. As experiment, those chunks are about 1400KB.</p>
<p>Client and server also keep track of how many messages have been encrypted and decryped so far. This value is used in the encrypt/decrypt process. As far as I understand, this is for preventing producing the same encrypted value if one of the ends send the same message again.</p>
<p>There is a definition about the session ticket, I didn&rsquo;t deep dive into this concept. Generally, after the client and server get done on handshake, the server would send the session tickets to client, client can use this data to make another tls session without going through handshake process again. The network overhead would be well reduced.</p>
<h1 id="the-end">The end</h1>
<p>Beside this notes, I have a mini implementation to prove what I understand is correct. It is only for educational purpose since I find that the <strong>RFC#8446</strong> is really hard to completely implement.</p>
<p>Link to implementation: <a href="https://github.com/trieutrng/toy-tls">https://github.com/trieutrng/toy-tls</a></p>
<h1 id="references">References</h1>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8446">RFC 8446</a></li>
<li><a href="https://tls13.xargs.org/">The Illustrated TLS 1.3 Connection</a></li>
<li><a href="https://www.manning.com/books/real-world-cryptography">Real-World Cryptography</a></li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>
