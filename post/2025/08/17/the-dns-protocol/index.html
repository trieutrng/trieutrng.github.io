<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>The DNS Protocol | Trieu Truong</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/post/">Posts</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">The DNS Protocol</span></h1>

<h2 class="date">2025/08/17</h2>
</div>

<main>
<p>As an engineer in computer industry, everyone should be familiar with the DNS, how a domain is resolved into IP eventually. Yet not everyone understands how the protocol is defined and how the packet is contructed as well. Thus, this post will go through the DNS packet definition and provide an actual implemetation eventually.</p>
<h1 id="recall-the-dns">Recall the DNS</h1>
<p><img src="dns-flow.png" alt="DNS flow"></p>
<p>DNS is a hierarchical client-server protocol. Every individual domain (e.g., google.com, microsoft.com, etc) is managed by a DNS server which knows where exactly the machine that running the application and eventually return the IP of that machine.</p>
<p>When we register a domain for an IP, we are always being asked to set up some records such as A, AAAA, CNAME, etc,. So what does those records mean?</p>
<ul>
<li><strong>A</strong>: IPv4 address record</li>
<li><strong>AAAA</strong>: IPv6 address record</li>
<li><strong>MX</strong>: Mail exchange record. This directs mail to an email server</li>
<li><strong>TXT</strong>: Text record. This lets an admin store text notes in the record.</li>
<li><strong>Canonical name</strong>: Canonical name. This is used to forwards one domain or subdomain to another domain, does NOT provide an IP address.</li>
</ul>
<p>And so on, you can keep discovering them <a href="https://www.cloudflare.com/learning/dns/dns-records/">here</a>.
All the end server in the whole flow communicate by the same protocol to resolve exactly the responsible server.</p>
<p>So how the bytes is formed?</p>
<h1 id="dns-packet-structure">DNS packet structure</h1>
<p><img src="dns-message-format.png" alt="DNS packet structure"></p>
<p>First of all, the the packet begins with a header section, this one describes the entire packet, it contains some data and flags like ID, the type of packet (query or answer) and number of questions or answers based on the type. The receiver will get to understand the header and extract the data of the rest later on.</p>
<p>Next, we have the question section, this bunch of bytes store the question of the request which is domain name to resolve.</p>
<p>The answer bytes holds the tail of the question section, it is built for the response no matter the response belongs to the TLD server or Authoritative one.</p>
<p>For simplicity, the last 2 sections are Authority and Additional will be skipped for this post.</p>
<h1 id="dns-headers">DNS headers</h1>
<p><img src="dns-header.png" alt="DNS packet structure"></p>
<p>This section of bytes contains 13 fields:</p>
<ul>
<li><strong>ID</strong>: 16 bits value indicates the ID of the message<br></li>
<li><strong>QR</strong>: 1 bit for the type of message. 0 for query and 1 for response<br></li>
<li><strong>OPCODE</strong>: type of query<br></li>
<li><strong>AA</strong>: Indicates an authoritative answer<br></li>
<li><strong>TC</strong>: Is this message truncated? Then is should be resent using TCP protocol<br></li>
<li><strong>RD</strong>: We leave this bit set to indicate that we
want the DNS server to contact additional servers until it can complete our
request<br></li>
<li><strong>RA</strong>: Indicates in a response whether the DNS server supports recursion<br></li>
<li><strong>Z</strong>: Is unused and should be set to 0<br></li>
<li><strong>RCODE</strong>: The error of the message<br>
<img src="dns-rcode.png" alt="DNS RCODE">
<br></li>
<li><strong>QDCOUNT</strong>: Number of question entries<br></li>
<li><strong>ANCOUNT</strong>: Number of answers records<br></li>
<li><strong>NSCOUNT</strong>: Number of records in Authority section<br></li>
<li><strong>ARCOUNT</strong>: Number of records in Additional section<br></li>
</ul>
<pre><code class="language-c">int build_dns_packet(struct Query *query, char *packet) {
    ...

    // ID
    *buf++ = 0xAB; *buf++ = 0xCD; 

    // QR=0,OPCODE=0,AA=0,TC=0,RD=1,RA=0,Z=0,RCODE=0
    *buf++ = 0x01; *buf++ = 0x00; 

    // QDCOUNT = 1
    *buf++ = 0x00; *buf++ = 0x01; 

    // ANCOUNT = 0
    *buf++ = 0x00; *buf++ = 0x00; 

    // QDCOUNT = 0
    *buf++ = 0x00; *buf++ = 0x00; 

    // ARCOUNT = 0
    *buf++ = 0x00; *buf++ = 0x00; 

    ...
}
</code></pre>
<h1 id="dns-question">DNS question</h1>
<p><img src="dns-question.png" alt="DNS packet questions"></p>
<p>3 fields are described as:</p>
<ul>
<li><strong>NAME</strong>: The querying name that is serialized by a convention<br></li>
<li><strong>QTYPE</strong>: Type of the query<br>
<img src="dns-question-type.png" alt="DNS question type"></li>
<li><strong>QCLASS</strong>: A two octet code that specifies the class of the query. 0x0001 is indicate the Internet address</li>
</ul>
<h3 id="query-serialization">Query serialization</h3>
<p>The querying domain is specially serialized by some conventions. We first split the domains in to tokens. Each token will be placed into the name section as bytes consecutively and prepended by a 8 bits number which indicates the size of the token.</p>
<p>For example, the domain <a href="https://www.google.com">www.google.com</a> is splitted in to 3 tokens www, google and com. Then, the encoding will look like this:</p>
<p>| 3 | w | w | w | 6 | g | o | o | g | l | e | 3 | c | o | m | 0 |</p>
<p>The last 0 indicates the end of name.</p>
<pre><code class="language-c">int build_dns_packet(struct Query *query, char *packet) {
    ...

    char *p_size = buf++, *p_char = query-&gt;domain;
    while (*p_char) {
        if (*p_char == '.') {
            *p_size = (buf - p_size - 1);
            p_size = buf;
        } else {
            *buf = *p_char;
        }
        buf++;
        p_char++;
    };

    *p_size = (buf - p_size - 1);
    *buf++ = 0x00;                          // end name
    *buf++ = 0x00; *buf++ = query-&gt;type;    // QTYPE
    *buf++ = 0x00; *buf++ = 0x01;           // QCLASS = 1, internet

    ...
}
</code></pre>
<h1 id="dns-answer">DNS answer</h1>
<p><img src="dns-answer.png" alt="DNS packet answers"></p>
<p>The 3 fields NAME, TYPE, CLASS have the same format with the questions sections. There are 3 more new fields:</p>
<ul>
<li><strong>TTL</strong>: The time the results can be cached as seconds<br></li>
<li><strong>RDLENGTH</strong>: Length of RDATA field<br></li>
<li><strong>RDATA</strong>: Data&rsquo;s interpretation is dependent upon the type specified by TYPE</li>
</ul>
<pre><code class="language-c">void resolve_dns_response(char *dns_res, int res_size) {
    ...

    unsigned char *name;
    p_ans = get_name(res, p_ans, &amp;name);

    const unsigned int type = (*p_ans &lt;&lt; 8) + p_ans[1];
    p_ans += 2;

    const int class = (*p_ans &lt;&lt; 8) + p_ans[1];
    p_ans += 2;
    
    const unsigned int ttl = (*p_ans &lt;&lt; 24) + (p_ans[1] &lt;&lt; 16) + (p_ans[2] &lt;&lt; 8) + p_ans[3];
    p_ans += 4;

    const int rdlen = (*p_ans &lt;&lt; 8) + p_ans[1];
    p_ans += 2;

    if (rdlen == 4 &amp;&amp; type == A) {
        printf(&quot;%d.%d.%d.%d\n&quot;, p_ans[0], p_ans[1], p_ans[2], p_ans[3]);
    } else if (rdlen == 16 &amp;&amp; type == AAAA) {
        int j;
        for (j = 0; j &lt; rdlen; j+=2) {
            printf(&quot;%02x%02x&quot;, p_ans[j], p_ans[j+1]);
            if (j + 2 &lt; rdlen) printf(&quot;:&quot;);
        }
    } else if (type == TXT) {
        printf(&quot;\tTXT: '%.*s'\n&quot;, rdlen-1, p_ans+1);
    }

    ...
}
</code></pre>
<h1 id="dns-packet-compression">DNS packet compression</h1>
<p>A DNS response is sometimes required to repeat the same name multiple times. In this case, a DNS server may encode a pointer to an earlier name instead of sending the same name multiple times.</p>
<p>A pointer is indicated by a 16-bit value with the two most significant bits set. The lower 14 bits indicate the pointer value. This 14-bit value specifies the location of the name as an offset from the beginning of the message.</p>
<h1 id="the-protocol">The protocol</h1>
<p>By default, DNS uses UDP as default protocol and and DNS query or response should fit well inside one packet. However, if a DNS reponse indicate that the message is truncated, the TCP comes and shines, in this case, we fallback to query DNS with the same message format as we do with UDP.</p>
<h1 id="the-end">The end</h1>
<p><img src="dns-usage-1.png" alt="DNS usage 1"></p>
<p>The implementation is at <a href="https://github.com/trieutrng/dns-protocol">https://github.com/trieutrng/dns-protocol</a></p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

